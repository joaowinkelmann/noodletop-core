import { webcrypto } from 'crypto';
export class Rand {
    /**
     * Generates a high entropy random integer.
     *
     * @param min - The minimum value (inclusive).
     * @param max - The maximum value (inclusive).
     * @returns A random integer between min (inclusive) and max (inclusive).
     */
    static int(min: number = 0, max: number): number {
        return (
            webcrypto.getRandomValues(new Uint32Array(1))[0] % (max - min + 1) + min
        );
    }

    // Function to generate a random dice roll from a string of dice notation (e.g. "2d6+3", "d8-3" or "d8")
    static roll(diceNotation: string, showRolls: boolean, diceLimit: number = 100): string | number {
        // Check if the dice notation is valid
        if (!/^(\d*d\d+)([-+]\d+)*$/.test(diceNotation)) {
            return 'Invalid dice notation';
        }

        const matches = diceNotation.match(/(\d*)d(\d+)([-+]\d+)*/);

        const numDice = parseInt(matches[1], 10) || 1;
        const diceSides = parseInt(matches[2], 10);
        const modifiers = matches[0].match(/[-+]\d+/g) || [];

        const rolls: number[] = [];

        let total = 0;
        for (let i = 0; i < Math.min(numDice, diceLimit); i++) {
            const roll = this.int(1, diceSides);
            rolls.push(roll);
            total += roll;
        }

        // Adjust the total based on the modifiers
        modifiers.forEach((modifier) => {
            const modifierSign = modifier[0];
            const modifierValue = parseInt(modifier.slice(1), 10);

            if (modifierSign === '+') {
                total += modifierValue;
            } else if (modifierSign === '-') {
                total -= Math.abs(modifierValue);
            }
        });

        if (showRolls) {
            return `${total} (${rolls.join(', ')})${modifiers.join('')}`;
        } else {
            return total;
        }
    }

    /**
     * Generates a random alphanumeric ID of a given length.
     * @param length The length of the ID string. Default is 8. (Collision probability is 1 in 62^length within the same millisecond)
     * @param includeTimestamp Adds a base36 encoded string of milliseconds since epoch at the start of the ID. Default is true.
     * @returns The generated ID string.
     */
    static id(length: number = 8, includeTimestamp: boolean = true): string {
        let result = '';
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const charactersLength = characters.length;
        for (let i = 0; i < length; i++) {
            result += characters.charAt(this.int(0, charactersLength - 1));
        }
        if (includeTimestamp) {
            let timestampString = Date.now().toString(36); // 8 characters representing the timestamp
            // Scramble the timestamp string
            const base36 = '0123456789abcdefghijklmnopqrstuvwxyz';
            // TODO: (Maybe pile) scramble the base36 string, making some of the characters uppercase as well
            // const base36 = 'CkPmw4ax08gYtnSij9613e2flHouQ5DvR7zb';
            const scrambledBase36 = base36.slice(length % 36) + base36.slice(0, length % 36);
            timestampString = timestampString.split('').map((char) => {
                const index = base36.indexOf(char);
                return scrambledBase36[index];
            }).join('');
            result = timestampString + result;
        }
        return result;
    }

    // returns a Date object from an ID generated by the id() method
    /**
     * Converts an ID string into a Date object.
     * Assumes that the timestamp takes up 8 characters in the given string.
     * @param id - The ID string to convert.
     * @returns 'Sat Apr 20 2024 10:14:41 GMT-0300 (Brasilia Standard Time)' - A Date object representing the timestamp encoded in the ID.
     */
    static dateFromId(id: string): Date {
        const length = id.length - 8; // retrieve the length from the id, assuming that the timestamp takes up 8 characters in the given string
        let timestampString = id.slice(0, 8); // gets the first 8 characters from the id
        // Unscramble the timestamp string
        // const saltedBase36 = 'CkPmw4ax08gYtnSij9613e2flHouQ5DvR7zb';
        const base36       = '0123456789abcdefghijklmnopqrstuvwxyz';

        const scrambledBase36 = base36.slice(length % 36) + base36.slice(0, length % 36);
        timestampString = timestampString.split('').map((char) => {
            const index = scrambledBase36.indexOf(char);
            return base36[index];
        }).join('');
        const timestamp = parseInt(timestampString, 36);
        // retuns the int associated with the id, taking into
        return new Date(timestamp);
    }

    /**
     * Generates a random color in hexadecimal format.
     * @param saturated - A boolean indicating whether the generated color should be more saturated (not grayed out). Default is true.
     * @returns - #FF22BB - String of a color in hexadecimal format.
     */
    static color(saturated: boolean = true): string {
        const rgb = [0, 0, 0];

        if (saturated) {
            // Let's choose between one or two channels and "amp" them up, by keeping their values high
            const numChannels = this.int(1, 2);

            for (let i = 0; i < numChannels; i++) {
                rgb[this.int(0, 2)] = this.int(180, 255);
            }

            // Keeping the remaining channel(s) at a low value, preventing "grayish" colors
            for (let i = 0; i < 3; i++) {
                if (rgb[i] === 0) {
                    rgb[i] = this.int(0, 64);
                }
            }
        } else {
            for (let i = 0; i < 3; i++) {
                rgb[i] = this.int(0, 255);
            }
        }
        return `#${rgb.map((c) => c.toString(16).padStart(2, '0')).join('')}`;
    }
}
